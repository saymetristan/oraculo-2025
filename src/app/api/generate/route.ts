[{"text": "import { NextRequest, NextResponse } from 'next/server'\nimport { getOpenAI } from '@/lib/openai'\nimport { ORACLE_SYSTEM_PROMPT, buildUserPrompt, TAROT_IMAGE_PROMPT } from '@/lib/prompts'\nimport { RitualAnswers, OracleReading } from '@/lib/types'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const answers: RitualAnswers = await request.json()\n\n    // Validate answers\n    if (!answers.palabra || !answers.elemento) {\n      return NextResponse.json(\n        { error: 'Missing required fields' },\n        { status: 400 }\n      )\n    }\n\n    const openai = getOpenAI()\n\n    // Generate reading with GPT-5.2 using Responses API\n    const textResponse = await openai.responses.create({\n      model: 'gpt-5.2',\n      input: `${ORACLE_SYSTEM_PROMPT}\\n\\n${buildUserPrompt(answers)}\\n\\nResponde \u00daNICAMENTE con el objeto JSON, sin texto adicional antes o despu\u00e9s.`\n    })\n\n    // Parse the JSON response from output\n    let readingData\n    try {\n      // Use the output_text helper for simplicity\n      let outputText = textResponse.output_text || ''\n      \n      // If no helper text, manually extract from message content\n      if (!outputText) {\n        const messageItem = textResponse.output.find((item: any) => item.type === 'message')\n        if (messageItem && 'content' in messageItem) {\n          const textContent = messageItem.content?.find((c: any) => c.type === 'output_text')\n          if (textContent && 'text' in textContent) {\n            outputText = textContent.text\n          }\n        }\n      }\n      \n      // Clean any markdown code blocks if present\n      outputText = outputText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim()\n      \n      if (!outputText) {\n        console.error('No text output found in response:', JSON.stringify(textResponse.output))\n        throw new Error('No text content in response')\n      }\n      \n      readingData = JSON.parse(outputText)\n    } catch (parseError) {\n      console.error('Failed to parse AI response:', parseError)\n      console.error('Raw output:', JSON.stringify(textResponse.output))\n      return NextResponse.json(\n        { error: 'Failed to parse oracle response' },\n        { status: 500 }\n      )\n    }\n\n    // Generate tarot card image with gpt-image-1.5\n    const imagePrompt = TAROT_IMAGE_PROMPT(\n      readingData.carta_nombre,\n      answers.elemento,\n      readingData.carta_significado\n    )\n\n    let imageBase64 = null\n    try {\n      const imageResponse = await openai.images.generate({\n        model: 'gpt-image-1.5',\n        prompt: imagePrompt,\n        size: '1024x1536', // Portrait for tarot card\n        quality: 'high',\n      })\n\n      if (imageResponse.data && imageResponse.data[0]) {\n        // gpt-image-1.5 returns base64 by default, or url depending on SDK version\n        imageBase64 = imageResponse.data[0].b64_json || imageResponse.data[0].url\n      }\n    } catch (imageError) {\n      console.error('Failed to generate image:', imageError)\n      // Continue without image - we'll use a fallback\n    }\n\n    // Generate unique ID\n    const id = `oracle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n    const reading: OracleReading = {\n      id,\n      veredicto: readingData.veredicto,\n      carta_nombre: readingData.carta_nombre,\n      carta_significado: readingData.carta_significado,\n      carta_imagen: imageBase64 || undefined,\n      profecias: readingData.profecias,\n      elemento: readingData.elemento,\n      ritual_cierre: readingData.ritual_cierre,\n      is_paid: false,\n      created_at: new Date().toISOString(),\n    }\n\n    return NextResponse.json(reading)\n  } catch (error) {\n    console.error('Error generating reading:', error)\n    return NextResponse.json(\n      { error: 'Failed to generate reading' },\n      { status: 500 }\n    )\n  }\n}\n", "type": "text"}]